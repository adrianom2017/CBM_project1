# -*- coding: utf-8 -*-
"""CBM_DNASequencing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tiBwz-hKc6-PX1XuMuGJR-ktvKd01eK5
"""

#Load small data

!wget --no-check https://public.bmi.inf.ethz.ch/teaching/cbm1_2019/project1/data_small/genome.chr22.5K.fa

import numpy as np

# read chr22
def readgeno(filename):
  geno=''
  with open(filename,'r') as f:
    for line in f:
      #ingnore header line
      if not line[0] =='>':
       geno += line.rstrip()
  return geno

chr22=readgeno('genome.chr22.5K.fa')

def readFastq(filename):
  reads=[]
  qualities=[]
  with open(filename,'r') as fh:
    while True:
      fh.readline()
      read=fh.readline().rstrip()
      fh.readline()
      quality=fh.readline().rstrip()
      if len(read) == 0:
        break
      reads.append(read)
      qualities.append(quality)
  return reads,qualities

from google.colab import files
uploaded = files.upload()

tiny1, _ =readFastq('output_tiny_30xCov1.fq')
tiny2, _ =readFastq('output_tiny_30xCov2.fq')

#Burrows-Wheeler Transformation

def BWT(geno):
  geno = geno + "$"
  index = 1
  rotations={1:geno}
  for i in geno:
    geno = geno[1:] + geno[0]
    index += 1 
    rotations={**rotations, **{index : geno}} 
    if geno[0] == "$":
      break
  return rotations

import operator
def BWT_ordered(rotations):
  L=''
  BWT_ordered = {}
  BWT_ordered = sorted(rotations.items(), key=operator.itemgetter(1))
  #save last column as L
  for r in BWT_ordered:
     L = L + r[1][-1]
  return BWT_ordered, L

#use example on the slides to test: BWT_ordered(BWT('TAGAGA'))[1]

#FM Index

def Occurance(L,k):
  array_C={}
  
  for c in ["$","A","C","G","T"]:
    occ=0
    for l in L[:k]:
      if l<c:
        occ+=1
    array_C = {**array_C, **{c : occ}}
  return array_C

# testing:
#Occurance('AGGTAA$',3)

def OccuranceMatrix(L,c,k):
  occ_matrix={}
  
  for base in ["$","A","C","G","T"]:
    occ=0
    for l in L[:k]:
      if l==base:
        occ+=1
    occ_matrix = {**occ_matrix, **{base : occ}}
  return c,occ_matrix[c]

# testing:
#OccuranceMatrix('AGGTAA$','A',7)

#FMIndex range matching
def FMIndex(L,P,geno):
  i = len(P)
  base = P[i-1]
  next_base = P[i-2]
  sp = Occurance(L,len(L))[base] + 1
  ep = Occurance(L,len(L))[next_base]

  while True:
    base = P[i-2]
    sp = Occurance(L,len(L))[base] + OccuranceMatrix(L,base,sp-1)[1] + 1
    ep = Occurance(L,len(L))[base] + OccuranceMatrix(L,base,ep)[1]
    i=i-1

    if (sp > ep or i<2):
      break
  
  #LF-mapping for search
  rotations=BWT(geno)
  hit_range1=BWT_ordered(rotations)[0][ep-1]
  hit_range2=BWT_ordered(rotations)[0][sp-1]
  
  return hit_range1,hit_range2

# testing:
#FMIndex('AGGTAA$','AGA','TAGAGA')


# test chr22 and one-direction reads
# haven't consider paired reads and multi A seq issue

geno=chr22
rotations=BWT(geno)

#Loop though all reads
mapping={}
for read in tiny1:
  mapping = {**mapping, **{read : FMIndex(L,read,geno)}}

mapping
